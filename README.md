## Create a new project called GA_Inheritance_Access_YourName

### Lecture Video - Must Review
### https://youtu.be/o-loXcTN0kM?si=hAP6Oyut7757WDQf

## Accessible Steps Required
**Creating a New Class:**

1. Open your project in Visual Studio.
2. To add a new class, you can use the keyboard shortcut `Ctrl + Shift + A`. This opens the "Add New Item" dialog.
3. In the dialog, use the arrow keys to select "Class" and then press Enter. This creates a new class file.

**Naming and Saving the Class:**

1. Type the name of your class (e.g., `Square`) in the name field.
2. Press `Enter` to create the class.

**Inheriting from Another Class Using Hotkeys:**

1. Once your new class file is open, type your class definition. For example, type `internal class Square`.
2. To inherit from another class (e.g., `Shape`), type a colon (`:`) followed by the name of the base class (`Shape`).
3. Your class declaration should look like `internal class Square : Shape`.
4. Use `Tab` and `Enter` keys to navigate and add properties or methods to your class.

---

## Requirements

1. **Create Classes:**
    
    - Implement `Shape`, `Polygon`, `Triangle`, and `Square` classes with the provided specifications.
    - Ensure each class inherits appropriately, as discussed in the previous sections.
2. **Implement Methods:**
    
    - Each class should correctly override the `ToString()` method.
    - Additional methods or properties relevant to each class should be implemented (e.g., `NumOfSides` for `Polygon`).
3. **Demonstrate Polymorphism:**
    
    - In the `Program` class, demonstrate polymorphism through object creation and method calling.
4. **Proper Use of Inheritance:**
    
    - Show a clear hierarchy and relationship between the classes.
5. **Code Quality:**
    
    - Code should be well-organized, properly indented, and commented.
    - Follow C# naming conventions and best practices.

---


### Tutorial on Object-Oriented Programming with Shape, Triangle, and Polygon Classes

#### Accessibility Note:

For screen reader users, it's important to remember that as you type and navigate through the IntelliSense suggestions, the screen reader should read out the highlighted options, helping you select the correct method or property. Ensure that your screen reader is configured correctly with Visual Studio for an optimal experience.

---

Alright, let's dive into the concept of inheritance in programming, specifically in the context of object-oriented programming (OOP). We'll build a class called `Shape` to illustrate these concepts. As a blind programmer using a screen reader and hotkeys in Visual Studio, you'll rely on auditory feedback and keyboard commands to navigate and write code. I'll guide you through this process step by step.

### Concept of Inheritance:

Inheritance is like creating a family tree for classes. Imagine a general category, like 'Shape,' which is a broad term that can include specific types like circles, squares, and triangles. In programming, the 'Shape' class is called the parent or base class, and the specific shapes like circles, squares, etc., are called child or derived classes. The child classes inherit properties and behaviors from the parent class, just like a child might inherit traits from their parents.

### Building the `Shape` Class:

`Full Code for Shape Class`
```csharp
internal class Shape
{
    string _color;

    public Shape(string color)
    {
        _color = color;
    }

    public override string ToString()
    {
        return $"This is a basic {_color} Shape Object";
    }
}
```

**Purpose of the Shape Class:**
- The `Shape` class serves as a fundamental building block in our object-oriented model. It represents the general concept of a shape, which can have various specific forms like triangles, polygons, etc.
- A shape is usually characterized by its dimensions (2D, 3D), and for our purpose, we'll focus on the color attribute.

1. **Creating the Class:**
   - Use the shortcut `Ctrl+Shift+A` to create a new class in Visual Studio. Name it `Shape`.
   - Your screen reader will read out the boilerplate code generated by Visual Studio.

2. **Adding a Property:**
   - We'll add a string property for color. This represents a characteristic that all shapes will have.
   - Type `public string Color { get; set; }`. The screen reader will read each keypress, assisting you in ensuring accuracy.

3. **Constructor:**
   - A constructor is a special method used to create and initialize objects. 
   - Type `public Shape(string color) { this.Color = color; }`. Here, `this.Color` refers to the Color property of the Shape class.

4. **Overriding ToString Method:**
   - The `ToString` method is used to return a string representation of an object. We'll override it to make it more meaningful for shapes.
   - Type `public override string ToString() { return $"Shape with color {Color}"; }`.
   - The `override` keyword is used to provide a new implementation for a method that is inherited from the parent class.

### Emphasizing Screen Reader and Hotkeys:

- **Navigation:**
  - Use `Ctrl+]` to jump between the opening and closing braces of methods and classes.
  - Use arrow keys to move line by line and hear the code read out.

- **Code Completion:**
  - Rely on IntelliSense (Visual Studio's code completion feature). When you start typing, it suggests completions. Press `Tab` to accept a suggestion.
  - The screen reader will read out the suggested completions.

- **Error Checking:**
  - Visual Studio will highlight errors. Use `Ctrl+.` to hear suggestions for fixing errors.

- **Running the Code:**
  - Use `F5` to run the program. Visual Studio's error window and output window are also screen reader accessible.

By building this `Shape` class, you're setting the foundation. Later, when you create specific shape classes like `Circle` or `Square`, they can inherit from `Shape` and have the `Color` property and the overridden `ToString` method, plus any additional properties or methods unique to those shapes.

Inheritance allows for code reusability and a cleaner organizational structure. It's like having a master blueprint (`Shape`) from which you can create more detailed and specific blueprints (`Circle`, `Square`, etc.).


---

### Creating a new class, Polygon. And then inheriting from Shape

Explanation: 
Inheritance is a fundamental concept in object-oriented programming (OOP) that allows you to create a new class based on an existing class. It enables you to reuse the code and functionality of an existing class while also allowing you to extend or modify it to create a more specialized or specific class. Inheritance forms a hierarchical relationship between classes, where a new class (called a derived class or subclass) inherits properties, methods, and fields from an existing class (called a base class or superclass).

**Purpose of the Polygon Class:**
- The `Polygon` class represents shapes with a variable number of sides, making it more versatile than a specific shape like a triangle.

**Code Explanation:**
- Inherits from `Shape`, gaining access to the `_color` attribute.
- Adds a new field `_numOfSides` to store the number of sides.
- The constructor initializes both color and the number of sides.
- Overrides `ToString()` to include information about the number of sides along with the color.

```csharp
internal class Polygon : Shape
{
    private int _numOfSides;

    public Polygon(string color, int numOfSides) : base(color)
    {
        _numOfSides = numOfSides;
    }

    public int NumOfSides { get => _numOfSides; protected set => _numOfSides = value; }

    public override string ToString()
    {
        return base.ToString() + $" a polygon with {_numOfSides} sides";
    }
}
```

1. Create a new class, Polygon.
	1. Use the following hotkeys to create a new class:
	   - In Visual Studio, you can use the hotkey `Ctrl + Shift + A` to open the "Add New Item" dialog.

- 1. **Inheritance Declaration:**
   - `internal class Polygon : Shape` declares that `Polygon` is inheriting from `Shape`. This means `Polygon` will have all the properties and methods of `Shape`, plus any additional ones you define.
   - Navigation: When you hear "internal class Polygon," use `Right Arrow` to move through the class name and inheritance part. The screen reader will read "colon Shape," indicating inheritance from the `Shape` class.

2. 2. **Private Field `_numOfSides`:**
   - This is a private integer field to store the number of sides. The underscore prefix (`_numOfSides`) is a common convention to indicate a private field.
   - Navigation: After the inheritance line, use `Down Arrow` to move to the next line. The screen reader will read the declaration of the private field. Use `Right Arrow` to explore each part of this line.

3. **Constructor:**
   - `public Polygon(string color, int numOfSides) : base(color) {...}`:
     - This is the constructor for the `Polygon` class.
     - It takes two parameters: `color` and `numOfSides`.
     - `: base(color)` calls the constructor of the base class (`Shape`) to initialize the `Color` property.
     - `_numOfSides = numOfSides;` initializes the `_numOfSides` field with the provided `numOfSides` argument.
   - Navigation: 
     - Move to this line using `Down Arrow`.
     - As you navigate this line, the screen reader will read out each part, including the parameters and the call to the base constructor.
     - Use `Ctrl+]` to jump to the end of the constructor block if needed.

4. **Property `NumOfSides`:**
   - This property provides access to the `_numOfSides` field.
   - `get => _numOfSides;` is a getter that returns the value of `_numOfSides`.
   - `protected set => _numOfSides = value;` is a setter that allows classes that inherit from `Polygon` to set the value of `_numOfSides`.
   - Navigation: 
     - Move down to this property using `Down Arrow`.
     - Explore each part of the property (getter and setter) using `Right Arrow`.
     - Note how the getter is public and the setter is protected, which will be read out by the screen reader.

5. **Overriding the `ToString` Method:**
   - `public override string ToString()` overrides the `ToString` method from the `Shape` class.
   - `return base.ToString() + $" a polygon with {_numOfSides} sides";` concatenates the string representation from `Shape` with additional information about the number of sides.
   - Navigation: 
     - Use `Down Arrow` to reach this method.
     - The screen reader will read "public override string ToString."
     - Use `Right Arrow` to hear the implementation details.
     - To explore the content within the method, use `Right Arrow` and `Left Arrow` to navigate through the return statement.

6. **General Navigation Tips:**
   - To hear the structure of the class, use `Ctrl+M, Ctrl+O` to collapse all members. Then, navigate with `Up Arrow` and `Down Arrow`.
   - To expand a method or property, use `Ctrl+M, Ctrl+M` when focused on a collapsed member.
   - For IntelliSense suggestions, as you type, the screen reader will announce the available completions. Press `Tab` to select a suggestion.

By incorporating these navigation steps into your coding process, you'll be able to interact more efficiently with the code in Visual Studio, ensuring that your coding experience is as smooth and accessible as possible.

---

## Creating a Triangle class, to inherit from Polygon

The provided code for the `Triangle` class in C# is a great example of multi-level inheritance in object-oriented programming. Here's how the `Triangle` class is inheriting from `Polygon`, and indirectly from `Shape`:

```csharp
internal class Triangle : Polygon
{
    // Existing constructor and properties
    
    public Triangle(string color, int numOfSides = 3) : base(color, numOfSides = 3)
    {
    }

    public override string ToString()
    {
        // Custom logic for ToString
        return base.ToString() + $" and a triangle with {NumOfSides} sides";
    }
}
```

1. **Inheritance Chain:**
   - `Shape` is the base class, providing fundamental properties like `_color`.
   - `Polygon` is a subclass of `Shape`, extending its functionality to represent shapes with multiple sides.
   - `Triangle` is a subclass of `Polygon`, further specializing to represent a specific shape – a triangle.

2. **Inheritance from `Polygon`:**
   - By declaring `Triangle` with `: Polygon`, it inherits all the properties and methods of `Polygon`.
   - This includes the properties and methods `Polygon` inherited from `Shape`, like the `_color` attribute.
   - Therefore, `Triangle` has access to both the `_color` attribute from `Shape` and the `_numOfSides` attribute from `Polygon`.

3. **Constructor of `Triangle`:**
   - The constructor for `Triangle` (not shown in the snippet) likely calls the constructor of `Polygon`, passing the color and setting the number of sides to 3 (since a triangle always has three sides).
   - This constructor setup ensures that `Triangle` instances are initialized with the appropriate number of sides and color.

4. **Overridden `ToString` Method:**
   - The `ToString` method in `Triangle` is overridden to provide specific information about triangles.
   - It calls `base.ToString()` to utilize the `ToString` implementation of `Polygon`, which in turn includes the color information from `Shape`.
   - The result is a concatenated string that includes both the color from `Shape` and the specific number of sides (3) pertinent to a triangle.

5. **Summary of Inheritance Benefits:**
   - **Code Reusability:** `Triangle` reuses code from both `Polygon` and `Shape`, reducing redundancy.
   - **Specialization:** While `Triangle` inherits general properties, it also specifies attributes unique to triangles (like having 3 sides).
   - **Maintainability:** Changes in the `Shape` or `Polygon` class will automatically propagate to `Triangle`, simplifying maintenance.

In essence, `Triangle` is a specialized form of `Polygon` which is, in turn, a specialized form of `Shape`. This inheritance structure exemplifies how complex objects can be created in an organized and efficient manner in object-oriented programming.

---

#### Step 4: Utilizing the Classes in the Program

**Creating Instances and Displaying Information:**
- In the `Program` class, we create instances of `Shape`, `Triangle`, and `Polygon`.
- We demonstrate polymorphism by assigning a `Triangle` instance to an `Object` type and then casting it back to `Triangle`.

**Code Snippets:**
```csharp
Shape shape1 = new Shape("blue");
Console.WriteLine(shape1.ToString());

Polygon poly1 = new Polygon("red", 6);
Console.WriteLine(poly1);

Triangle triangle = new Triangle("green");
Console.WriteLine(triangle.ToString());

Object triangle2 = new Triangle("blue", 3);
Console.WriteLine(triangle2.ToString());
```

**Demonstrating Polymorphism and Casting:**
- By assigning `triangle2` as an `Object`, we demonstrate how an instance of `Triangle` can be viewed as a generic `Object`.
- When we use `ToString()` on `triangle2`, it still calls the `Triangle` class's `ToString()` method, showing polymorphism in action.
- Casting `triangle2` back to `Triangle` (`Triangle backToTriangle = (Triangle)triangle2;`) allows us to regain access to `Triangle`-specific properties and methods.

Your example in C# nicely illustrates some key concepts in object-oriented programming, including inheritance, polymorphism, and the universal nature of the `Object` class in .NET. Here's an expansion of your example with expected results and an explanation of the "everything is an object" concept:

### Expected Results from the Code Snippets

1. **Shape Instance:**
   - Creates a `Shape` object with color "blue".
   - The `ToString()` method for `Shape` is called, expected to return information about the shape's color.
     - Expected Output: A string indicating that it's a shape with blue color.

2. **Polygon Instance:**
   - Creates a `Polygon` object with color "red" and 6 sides.
   - The `ToString()` method for `Polygon` is called, expected to include information about color and the number of sides.
     - Expected Output: A string indicating it's a polygon with red color and 6 sides.

3. **Triangle Instance:**
   - Creates a `Triangle` object with color "green".
   - The `ToString()` method for `Triangle` is called, which includes color and the specific number of sides (3).
     - Expected Output: A string indicating it's a triangle with green color and 3 sides.

4. **Triangle as Object:**
   - Creates another `Triangle` object, but this time it's referenced as an `Object` type.
   - Despite being referenced as `Object`, calling `ToString()` still invokes the `ToString` method of the `Triangle` class due to polymorphism.
     - Expected Output: A string indicating it's a triangle with blue color and 3 sides.

5. **Casting Back to Triangle:**
   - Casting `triangle2` back to `Triangle` would allow access to `Triangle`-specific properties/methods not available in the `Object` class.

---

## Explaining Casting

Casting in programming is a way to convert an object of one type into another type. In your C# example, casting is used to demonstrate polymorphism and to manipulate objects of different types in a class hierarchy. Let's break down the types of casting illustrated in your example:

### 1. Upcasting
Upcasting is converting a derived class object to a base class object. It's implicit and safe because the derived class object is always an instance of its base class.

- **Example from your code:**
  ```csharp
  Object triangle2 = new Triangle("blue", 3);
  ```
  Here, `triangle2` is an instance of `Triangle` but is being treated as an `Object` (the ultimate base class in C#). This is upcasting. `Triangle` is automatically an `Object` because every class in C# inherits from `Object` at the root level.

### 2. Downcasting
Downcasting is the opposite of upcasting, where you convert a base class object to a derived class object. Downcasting requires explicit cast notation and can be risky if not used carefully, as it can lead to runtime errors if the object doesn't actually belong to the type you're casting to.

- **Example from your code:**
  ```csharp
  Triangle backToTriangle = (Triangle)triangle2;
  ```
  In this line, `triangle2` is cast back to a `Triangle`. This is downcasting. Since we know `triangle2` is actually a `Triangle`, this cast is safe. If `triangle2` were not a `Triangle`, this would throw an exception at runtime.

### Demonstrating Polymorphism with Casting
Your example also showcases polymorphism. When `ToString()` is called on `triangle2`, the overridden `ToString()` method in the `Triangle` class is executed, even though `triangle2` is referenced as an `Object`. This is because the actual object type at runtime is `Triangle`, and so its specific implementation of `ToString()` is used. This is a key aspect of polymorphism – the method that gets executed depends on the actual object type, not the type it's referred to at the moment.

### Conclusion
In summary, casting is a fundamental concept in object-oriented programming that allows programmers to work with objects in a more flexible manner. Upcasting allows for generalization (treating a specialized object as a more general type), while downcasting enables specialization (treating a general object as a more specific type). Polymorphism enhances this by allowing objects to behave differently based on their actual type, even when referenced through a more general type.

### Explanation: Everything is an Object

In C#, the `Object` class is the root of all classes in the .NET Framework class hierarchy. It's the ultimate base class from which all other classes derive, either directly or indirectly. This is why we say "everything is an object" in .NET. Here's what this implies:

- **Common Methods:** All types in .NET inherit a set of standard methods from `Object`, such as `ToString()`, `Equals()`, `GetType()`, and `GetHashCode()`. This is why, for instance, you can call `ToString()` on any object, even if it's referenced as `Object`.
  
- **Polymorphism:** When a derived class (like `Triangle`) overrides a method (like `ToString()`) from the base `Object` class, that overridden version is called even when the object is referenced as an `Object`. This demonstrates polymorphism, where an object can take many forms.

- **Boxing and Unboxing:** The concept of treating a derived type (like `Triangle`) as an `Object` is known as boxing, and converting it back to a specific type is known as unboxing. This is what you're demonstrating by assigning `triangle2` to an `Object` and then casting it back.

- **Flexibility and Interoperability:** The universal nature of `Object` allows for a high degree of flexibility and interoperability within the .NET framework. It enables a common way to handle different types and to create collections that can store any type of object.

In summary, the example you provided not only demonstrates how inheritance and polymorphism work in C#, but also shows the fundamental principle of .NET that every class is derived from the `Object` class, offering a shared set of methods and enabling polymorphic behavior.

---
## Submit your GitHub repo online

---

## Rubric

| Name                  | Description                                                        | Points |
|-----------------------|--------------------------------------------------------------------|--------|
| Project Setup         | Properly naming and setting up the GitHub repository               | 10     |
| Class Implementation  | Correct creation and structuring of classes (`Shape`, `Polygon`, `Triangle`, `Square`) | 20     |
| Inheritance           | Proper use of inheritance in class hierarchy                       | 10     |
| Polymorphism          | Correct demonstration of polymorphism in the `Program` class       | 10     |
| Method Overriding     | Appropriately overridden `ToString()` method in each class         | 15     |
| Code Quality          | Adherence to C# naming conventions, code organization, indentation, and commenting | 25     |
| Documentation         | Quality and clarity of README documentation                        | 20     |
